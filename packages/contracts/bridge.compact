pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

enum BridgeState {
  NOT_INITIATED,
  INITIATED,
  COMPLETED
}

export ledger bridgingIntentsState: Map<Bytes<32>, BridgeState>;
export ledger bridgingIntentsAmount: Map<Bytes<32>, Uint<64>>;
export ledger bridgeCoin: QualifiedCoinInfo;

export circuit initiateBridge(secretHashed: Bytes<32>, amount: Uint<64>, coin: CoinInfo): [] {
    const disclosedSecretHashed = disclose(secretHashed);

    // if already initiated
    if (bridgingIntentsState.member(disclosedSecretHashed)) {
        return;
    }

    // transfer fund from caller to contract
    const disclosedCoin = disclose(coin);


    receive(disclosedCoin);

    if (bridgeCoin.value == 0) {
        bridgeCoin.writeCoin(
        disclosedCoin,
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    } else {
        bridgeCoin.writeCoin(
        mergeCoinImmediate(bridgeCoin, disclosedCoin),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }
    // store the secretHashed in bridgingIntentsState
    bridgingIntentsState.insert(disclosedSecretHashed, BridgeState.INITIATED);
    bridgingIntentsAmount.insert(disclosedSecretHashed, disclose(amount));

    return;
}

export circuit completeBridge(secret: Bytes<32>): [] {
    // hash the secret
    const hashedSecret = persistentHash<Bytes<32>>(secret);

    // read the hashedSecret from bridgingIntents to know if its exist
    if(!bridgingIntentsState.member(disclose(hashedSecret))) {
        return;
    }

    // if exist and is PENDING
    if(bridgingIntentsState.lookup(disclose(hashedSecret)) == BridgeState.INITIATED) {
        const user = ownPublicKey();
        // release fund to caller
        const sendResult = send(
            bridgeCoin,
            left<ZswapCoinPublicKey, ContractAddress>(user),
            bridgingIntentsAmount.lookup(disclose(hashedSecret))
        );
        
        if (sendResult.change.is_some) {
            bridgeCoin.writeCoin(
            sendResult.change.value,
            right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        } else {
            bridgeCoin.resetToDefault();
        }
    }

}